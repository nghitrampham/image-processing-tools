# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.3
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import cv2

import numpy as np 
from scipy import signal
from skimage import color
from matplotlib import pyplot as plt

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1063, 610)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")


        self.cbOriginalImage = QtWidgets.QComboBox(self.centralwidget)
        self.cbOriginalImage.setGeometry(QtCore.QRect(30, 380, 211, 170))
        self.cbOriginalImage.setObjectName("cbOriginalImage")
        self.cbOriginalImage.addItem("")
        self.cbOriginalImage.addItem("")
        self.cbOriginalImage.addItem("")

        self.cbProcessedImage = QtWidgets.QComboBox(self.centralwidget)
        self.cbProcessedImage.setGeometry(QtCore.QRect(350, 390, 231, 150))
        self.cbProcessedImage.setObjectName("cbProcessedImage")
        self.cbProcessedImage.addItem("Low Pass Filter")
        self.cbProcessedImage.addItem("Edge detection")
        self.cbProcessedImage.addItem("Specify Histogram Equalizer")
        self.cbProcessedImage.addItem("Pyramid Down")
        self.cbProcessedImage.addItem("Gaussian Blur")
        
        self.cbArtyImage = QtWidgets.QComboBox(self.centralwidget)
        self.cbArtyImage.setGeometry(QtCore.QRect(720, 400, 211, 130))
        self.cbArtyImage.setObjectName("cbArtyImage")
        self.cbArtyImage.addItem("")
        # self.cbArtyImage.addItem("")


        self.txtParamProcessed = QtWidgets.QTextEdit(self.centralwidget)
        self.txtParamProcessed.setGeometry(QtCore.QRect(350, 490, 150, 35))
        self.txtParamProcessed.setObjectName("txtParamProcessed")

        self.slProcessed = QtWidgets.QSlider(self.centralwidget)
        self.slProcessed.setGeometry(QtCore.QRect(520, 475, 160, 61))
        self.slProcessed.setOrientation(QtCore.Qt.Horizontal)
        self.slProcessed.setObjectName("slProcessed")

        self.txtParamProcessed1 = QtWidgets.QTextEdit(self.centralwidget)
        self.txtParamProcessed1.setGeometry(QtCore.QRect(350, 530, 150, 35))
        self.txtParamProcessed1.setObjectName("txtParamProcessed1")

        self.slProcessed1 = QtWidgets.QSlider(self.centralwidget)
        self.slProcessed1.setGeometry(QtCore.QRect(520, 515, 160, 61))
        self.slProcessed1.setOrientation(QtCore.Qt.Horizontal)
        self.slProcessed1.setObjectName("slProcessed1")


        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(720, 490, 150, 30))
        self.textEdit.setObjectName("textEdit")

        self.slArty = QtWidgets.QSlider(self.centralwidget)
        self.slArty.setGeometry(QtCore.QRect(880, 475, 160, 61))
        self.slArty.setOrientation(QtCore.Qt.Horizontal)
        self.slArty.setObjectName("slArty")



        self.lbOriginalImage = QtWidgets.QLabel(self.centralwidget)
        self.lbOriginalImage.setGeometry(QtCore.QRect(10, 0, 311, 401))
        self.lbOriginalImage.setObjectName("lbOriginalImage")
        self.lbProcessedImage = QtWidgets.QLabel(self.centralwidget)
        self.lbProcessedImage.setGeometry(QtCore.QRect(360, 0, 331, 401))
        self.lbProcessedImage.setObjectName("lbProcessedImage")
        self.lbArtyImage = QtWidgets.QLabel(self.centralwidget)
        self.lbArtyImage.setGeometry(QtCore.QRect(720, 0, 331, 401))
        self.lbArtyImage.setObjectName("lbArtyImage")


        self.pbOriginalImage = QtWidgets.QPushButton(self.centralwidget)
        self.pbOriginalImage.setGeometry(QtCore.QRect(100, 410, 112, 32))
        self.pbOriginalImage.setObjectName("pbOriginalImage")
        self.pbProcessedImage = QtWidgets.QPushButton(self.centralwidget)
        self.pbProcessedImage.setGeometry(QtCore.QRect(448, 410, 131, 32))
        self.pbProcessedImage.setObjectName("pbProcessedImage")
        self.pbArtyImage= QtWidgets.QPushButton(self.centralwidget)
        self.pbArtyImage.setGeometry(QtCore.QRect(815, 410, 161, 32))
        self.pbArtyImage.setObjectName("pbArtyImage")



        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1063, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        #########################################################
        #########################################################
        ####################### ADDED CODE ######################
        self.pbOriginalImage.clicked.connect(self.pressedOriginalImage)

        self.pbArtyImage.clicked.connect(self.pressedArtyEffect)
        self.slArty.valueChanged[int].connect(self.sliderArty)

        self.pbProcessedImage.clicked.connect(self.pressedProcessEffect)
        self.slProcessed.valueChanged[int].connect(self.sliderProcess)
        self.slProcessed1.valueChanged[int].connect(self.sliderProcess1)

    ###################### 
    def pressedOriginalImage(self):
        global fname
        image_name = str(self.cbOriginalImage.currentText())
        if image_name == "1. flowers":
            fname = "blue_flowers.jpg"
        elif image_name == "1. town":
            fname = "mocchau.jpg"
        else: 
            fname = "dragonfly.jpg"

        self.lbOriginalImage.setText("")
        self.lbOriginalImage.setPixmap(QtGui.QPixmap(fname))
        self.lbOriginalImage.setScaledContents(True)


    def sliderArty(self, value):
        effect = str(self.cbArtyImage.currentText())
        if effect == "5. water color":
            self.textEdit.setPlainText("Kernel Size: (" + str(value) + ", " + str(value) + ")")
            self.waterColor(kernel_size = value)


    def sliderProcess(self, value):
        processMethod = str(self.cbProcessedImage.currentText())
        if processMethod == "3. Low Pass Filter":
            self.slProcessed.setRange(3, 15)
            self.txtParamProcessed.setPlainText("Kernel Size: (" + str(value) + ", " + str(value) + ")")
            self.LPF(kernel_size = value)
        elif processMethod == "3. Edge Detection":
            s = self.slProcessed1.value()
            self.txtParamProcessed.setPlainText("Kernel Size: (" + str(value) + ", " + str(value) + ")")
            self.sobel(kernel_size = value, sigma = s)
        elif processMethod == "3. Gaussian Blur":
            s = self.slProcessed1.value()
            self.txtParamProcessed.setPlainText("Kernel Size: (" + str(value) + ", " + str(value) + ")")
            self.gaussianBlur(kernel_size = value, sigma = s)
        elif processMethod == "3. Specify Histogram Equalizer":
            s = self.slProcessed1.value()
            self.txtParamProcessed.setPlainText("mu: " + str(value))
            self.histogram_specification(mu=value, sigma = s)
        elif processMethod == "3. Pyramid Down":
            self.txtParamProcessed.setPlainText("Scale factor: " + str(value))
            self.pyrDown(s = value)


    def sliderProcess1(self, value):
        processMethod = str(self.cbProcessedImage.currentText())
        if processMethod == "3. Edge Detection":
            k = self.slProcessed.value()
            self.txtParamProcessed1.setPlainText("Sigma: " + str(value))
            self.sobel(kernel_size = k, sigma = value)
        elif processMethod == "3. Gaussian Blur":
            k = self.slProcessed.value()
            self.txtParamProcessed1.setPlainText("Sigma: " + str(value))
            self.gaussianBlur(kernel_size = k, sigma = value)
        elif processMethod == "3. Specify Histogram Equalizer":
            k = self.slProcessed.value()
            self.txtParamProcessed1.setPlainText("Sigma: " + str(value))
            self.histogram_specification(mu=k, sigma = value)
        

    #########################################################
    ###################### Image Proccessing ################
    #########################################################
    def pressedProcessEffect(self):
        processMethod = str(self.cbProcessedImage.currentText())
        if processMethod == "3. Low Pass Filter":
            self.txtParamProcessed1.setPlainText("Parameter Control")
            self.txtParamProcessed.setPlainText("Kernel Size: (3,3)")
            self.LPF()
        elif (processMethod == "3. Edge Detection") or (processMethod == "3. Gaussian Blur"):
            self.slProcessed.setRange(1, 25)
            self.slProcessed1.setRange(1, 5)
            self.txtParamProcessed.setPlainText("Kernel Size: (5,5)")
            self.txtParamProcessed1.setPlainText("Sigma: 1.0")
            if (processMethod == "3. Edge Detection"):
                self.sobel() 
            else:
                self.gaussianBlur()
        elif processMethod == "3. Specify Histogram Equalizer":
            self.slProcessed.setRange(150, 210)
            self.slProcessed1.setRange(5, 30)
            self.txtParamProcessed.setPlainText("mu: 180")
            self.txtParamProcessed1.setPlainText("Sigma: 20")
            self.histogram_specification()
        elif processMethod == "3. Pyramid Down":
            self.slProcessed.setRange(1, 10)
            self.txtParamProcessed1.setPlainText("Parameter Control")
            self.txtParamProcessed.setPlainText("Scale factor: 2")
            self.pyrDown()
        else:
            self.segmentation()

    def LPF(self, kernel_size = 3):
        image = cv2.imread(fname)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        kernel = (kernel_size, kernel_size)
        lpf = np.ones(kernel) / (kernel_size*kernel_size)
        image_lpf = image
        image_lpf[:,:,0] = signal.convolve2d(image[:,:,0], lpf, mode = "same")
        image_lpf[:,:,1] = signal.convolve2d(image[:,:,1], lpf, mode = "same")
        image_lpf[:,:,2] = signal.convolve2d(image[:,:,2], lpf, mode = "same")
        

        height, width = image_lpf.shape[:2]
        bytesPerLine = 3 * width
        img = QtGui.QImage(image_lpf.data, width, height, bytesPerLine, QtGui.QImage.Format_RGB888)
        pixmap = QtGui.QPixmap.fromImage(img)

        self.lbProcessedImage.setText("")
        self.lbProcessedImage.setPixmap(pixmap)
        self.lbProcessedImage.setScaledContents(True)


    def sobel(self, kernel_size = 5, sigma = 1.0):
        image = cv2.imread(fname)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = self.gaussian_filter(image, kernel_size, sigma)

        image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        h1 = np.array([[1, 0, -1], [2, 0 , -2], [1, 0, -1]])
        h2 = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]])
        
        m1 = signal.convolve2d(image, h1, mode = "same")
        m2 = signal.convolve2d(image, h2, mode = "same")
        
        m = np.sqrt(m1**2 + m2**2)
        m = m.astype(np.uint8)
        height, width = m.shape[:2]

        img = QtGui.QImage(m, width, height, QtGui.QImage.Format_Grayscale8)
        pixmap = QtGui.QPixmap.fromImage(img)

        self.lbProcessedImage.setText("")
        self.lbProcessedImage.setPixmap(pixmap)
        self.lbProcessedImage.setScaledContents(True)

    def gauss_kern(self, size = 5, sigma = 1.):
        ax = np.linspace(-(size - 1) / 2., (size - 1) / 2., size)
        xx, yy = np.meshgrid(ax, ax)
        kernel = np.exp(-0.5 * (np.square(xx) + np.square(yy)) / np.square(sigma))
        return kernel / (np.sum(kernel) + 1)

    def gaussian_filter(self, image, kernel_size=5, sigma = 1.0):
        gauss = self.gauss_kern(kernel_size, sigma)
        img_blur = image
        for c in range(image.shape[2]):
            img_blur[:,:,c] = signal.convolve2d(image[:,:,c], gauss, mode = 'same')
        return img_blur

    def gaussianBlur(self, kernel_size = 3, sigma = 1.0):
        image = cv2.imread(fname)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        height, width, channel = image.shape

        gauss = self.gauss_kern(kernel_size, sigma)
        img_blur = image
        for c in range(channel):
            img_blur[:,:,c] = signal.convolve2d(image[:,:,c], gauss, mode = 'same')
                
        bytesPerLine = 3 * width
        img = QtGui.QImage(img_blur.data, width, height, bytesPerLine, QtGui.QImage.Format_RGB888)
        pixmap = QtGui.QPixmap.fromImage(img)

        self.lbProcessedImage.setText("")
        self.lbProcessedImage.setPixmap(pixmap)
        self.lbProcessedImage.setScaledContents(True)

    def pyrDown(self, s = 2, kernel_size = 5, sigma = 1.0):
        image = cv2.imread(fname)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        gauss = self.gauss_kern(kernel_size, sigma)
        img_blur = image
        for c in range(image.shape[2]):
            img_blur[:,:,c] = signal.convolve2d(image[:,:,c], gauss, mode = 'same')

        img_blur = img_blur[::s, ::s, :].copy()

        height, width, _ = img_blur.shape
        bytesPerLine = 3 * width
        img = QtGui.QImage(img_blur.data, width, height, bytesPerLine, QtGui.QImage.Format_RGB888)
        pixmap = QtGui.QPixmap.fromImage(img)

        self.lbProcessedImage.setText("")
        self.lbProcessedImage.setPixmap(pixmap)
        # self.lbProcessedImage.setScaledContents(True)


    def compute_pdf_cdf(self, image2d):
        row, column = image2d.shape
        ### compute pdf and cdf
        pdf = np.zeros(256)
        for r in range(row):
            for c in range(column):
                if (image2d[r,c] >= 0) & (image2d[r,c] <= 255):
                    pdf[image2d[r,c]] += 1
        cum = np.zeros(256)
        for i in range(len(pdf)):
            cum[i] = np.sum(pdf[:i])
        return pdf, cum

    def histogram_specification(self, mu = 190, sigma = 20):
        image = cv2.imread(fname)
        ### get hsv 
        image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        H, S, V = cv2.split(image_hsv)
        v_pdf, v_cdf = self.compute_pdf_cdf(V)
        row, column = V.shape
        ### generate gaussian distribution
        gauss = np.round(np.random.normal(mu, sigma, [V.shape[0], V.shape[1]])).astype(int)
        g_pdf, g_cdf = self.compute_pdf_cdf(gauss)
        
        ### transform image
        transformed_V = V
        for r in range(row):
            for c in range(column):
                pixel_val = V[r,c]
                cdf_pixel = v_cdf[pixel_val]
                ## mapping
                index = np.argmin(abs(g_cdf - cdf_pixel))
                transformed_V[r,c] = index
        enhanced_image = image_hsv;
        enhanced_image[:,:,2] = transformed_V;
        enhanced_image = cv2.cvtColor(enhanced_image, cv2.COLOR_HSV2RGB)

        height, width, channel = image.shape
        bytesPerLine = 3 * width
        img = QtGui.QImage(enhanced_image.data, width, height, bytesPerLine, QtGui.QImage.Format_RGB888)
        pixmap = QtGui.QPixmap.fromImage(img)

        self.lbProcessedImage.setText("")
        self.lbProcessedImage.setPixmap(pixmap)
        self.lbProcessedImage.setScaledContents(True)
        


    #########################################################
    ###################### ARTY EFFECT ######################
    #########################################################
    def pressedArtyEffect(self):
        effect = str(self.cbArtyImage.currentText())
        if effect == "5. water color":
            self.slArty.setRange(3, 15)
            self.textEdit.setPlainText("Kernel Size : (9,9)")
            self.waterColor()
        else: 
            self.segmentation

    def segmentation(self):
        pass

    def waterColor(self, kernel_size = 9):
        image = cv2.imread(fname)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        water_image = image
        for c in range(image.shape[2]):
            temp_image = self.closing(image[:,:,c], ksize = kernel_size)
            water_image[:,:,c] = self.opening(temp_image, ksize = kernel_size)


        height, width = water_image.shape[:2]
        bytesPerLine = 3 * width
        img = QtGui.QImage(water_image.data, width, height, bytesPerLine, QtGui.QImage.Format_RGB888)
        pixmap = QtGui.QPixmap.fromImage(img)

        self.lbArtyImage.setText("")
        self.lbArtyImage.setPixmap(pixmap)
        self.lbArtyImage.setScaledContents(True)

    def erosion_dilation(self, im, op = "erosion", ksize = 5):
        """
        @param im: 2D image
        """
        if ksize % 2 == 0:
            ksize += 1
        h, w = im.shape[:2]
        s = ksize - 1
        latten_mat = []

        #### creating latten matrix which is the core of the algorithm
        for i in range(0, ksize):
            for j in np.arange(s, -1, -1):
                latten_mat.append(im[i:h-(s-i), j:w-(s-j)])
        matrix = np.stack(latten_mat)

        rmatrix = matrix.reshape(matrix.shape[0], matrix.shape[1]*matrix.shape[2]).T
        kernel = cv2.getStructuringElement(cv2.cv2.MORPH_ELLIPSE, (ksize,ksize))
        ker = np.repeat(kernel.reshape(1,-1), rmatrix.shape[0], axis = 0)
        result = np.multiply(ker, rmatrix)
        # result[result>255] = 255
        # result[result<0]=0
        if op == "erosion":
            filtered_image = np.min(np.where(result==0, result.max(), result), axis=1)
            # filtered_image = np.min(result, axis=1)
        else:
            filtered_image = np.max(np.where(result==0, result.min(), result), axis=1)
            # filtered_image = np.max(result, axis=1)
        filtered_image = filtered_image.reshape(matrix.shape[1],matrix.shape[2])
        eroded_im = im
        idx = int(s/2)
        eroded_im[idx:-idx, idx:-idx] = filtered_image
        
        return eroded_im

    def closing(self, im, ksize = 5):
        """
        Closing: dilation followed by erosion
        """
        temp = self.erosion_dilation(im, op = "dilation", ksize=ksize)
        result = self.erosion_dilation(temp, op = "erosion", ksize=ksize)
        return result

    def opening(self, im, ksize = 5):
        """
        Opening: erosion followed by dilation
        """
        temp = self.erosion_dilation(im, op = "erosion", ksize=ksize)
        result = self.erosion_dilation(temp, op = "dilation", ksize=ksize)
        return result

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.cbOriginalImage.setItemText(0, _translate("MainWindow", "1. flowers"))
        self.cbOriginalImage.setItemText(1, _translate("MainWindow", "1. town"))
        self.cbOriginalImage.setItemText(2, _translate("MainWindow", "1. butterfly"))
        self.cbProcessedImage.setItemText(0, _translate("MainWindow", "3. Low Pass Filter"))
        self.cbProcessedImage.setItemText(1, _translate("MainWindow", "3. Specify Histogram Equalizer"))
        self.cbProcessedImage.setItemText(2, _translate("MainWindow", "3. Pyramid Down"))
        self.cbProcessedImage.setItemText(3, _translate("MainWindow", "3. Edge Detection"))
        self.cbProcessedImage.setItemText(4, _translate("MainWindow", "3. Gaussian Blur"))
        self.cbArtyImage.setItemText(0, _translate("MainWindow", "5. water color"))
        # self.cbArtyImage.setItemText(1, _translate("MainWindow", "segmentation"))
        self.txtParamProcessed1.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'.AppleSystemUIFont\'; font-size:13pt; font-weight:400; font-style:normal;\">\n"
"<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">Parameter Control</span></p></body></html>"))
        self.txtParamProcessed.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'.AppleSystemUIFont\'; font-size:13pt; font-weight:400; font-style:normal;\">\n"
"<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">Parameter Control</span></p></body></html>"))
        self.textEdit.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'.AppleSystemUIFont\'; font-size:13pt; font-weight:400; font-style:normal;\">\n"
"<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Parameter Control</p></body></html>"))
        self.lbProcessedImage.setText(_translate("MainWindow", "TextLabel"))
        self.lbArtyImage.setText(_translate("MainWindow", "TextLabel"))
        self.pbOriginalImage.setText(_translate("MainWindow", "2. Read Image"))
        self.pbProcessedImage.setText(_translate("MainWindow", "4. Process Image"))
        self.pbArtyImage.setText(_translate("MainWindow", "6. Apply Arty Effect"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
